import {
  AnimatedObject,
  Controller,
  FluidValue,
  addFluidObserver,
  callFluidObservers,
  colors2,
  config,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  is,
  raf,
  removeFluidObserver,
  toArray,
  useMemoOne,
  useOnce
} from "./chunk-JHWXRGP7.js";
import {
  require_react_dom
} from "./chunk-44SAICON.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@react-spring/parallax/dist/react-spring_parallax.modern.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n) => "-" + n.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i) => {
    instance.setAttribute(name, values[i]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x, y, z, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x2, y2, z2, deg]) => [
            `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t, id] = this.transforms[i](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

// node_modules/@react-spring/parallax/dist/react-spring_parallax.modern.mjs
var ParentContext = React.createContext(null);
function getScrollType(horizontal) {
  return horizontal ? "scrollLeft" : "scrollTop";
}
function mapChildrenRecursive(children, callback) {
  const isReactFragment = (node) => {
    if (node.type) {
      return node.type === React.Fragment;
    }
    return node === React.Fragment;
  };
  return React.Children.map(
    children,
    (child) => isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child)
  );
}
var START_TRANSLATE_3D = "translate3d(0px,0px,0px)";
var START_TRANSLATE = "translate(0px,0px)";
var ParallaxLayer = React.memo(
  React.forwardRef(
    ({ horizontal, factor = 1, offset = 0, speed = 0, sticky, ...rest }, ref) => {
      const parent = (0, import_react.useContext)(ParentContext);
      const ctrl = useMemoOne(() => {
        let translate;
        if (sticky) {
          const start = sticky.start || 0;
          translate = start * parent.space;
        } else {
          const targetScroll = Math.floor(offset) * parent.space;
          const distance = parent.space * offset + targetScroll * speed;
          translate = -(parent.current * speed) + distance;
        }
        return new Controller({
          space: sticky ? parent.space : parent.space * factor,
          translate
        });
      }, []);
      const layer = useMemoOne(
        () => ({
          horizontal: horizontal === void 0 || sticky ? parent.horizontal : horizontal,
          sticky: void 0,
          isSticky: false,
          setPosition(height, scrollTop, immediate = false) {
            if (sticky) {
              setSticky(height, scrollTop);
            } else {
              const targetScroll = Math.floor(offset) * height;
              const distance = height * offset + targetScroll * speed;
              ctrl.start({
                translate: -(scrollTop * speed) + distance,
                config: parent.config,
                immediate
              });
            }
          },
          setHeight(height, immediate = false) {
            ctrl.start({
              space: sticky ? height : height * factor,
              config: parent.config,
              immediate
            });
          }
        }),
        []
      );
      useOnce(() => {
        if (sticky) {
          const start = sticky.start || 0;
          const end = sticky.end || start + 1;
          layer.sticky = { start, end };
        }
      });
      React.useImperativeHandle(ref, () => layer);
      const layerRef = (0, import_react.useRef)();
      const setSticky = (height, scrollTop) => {
        const start = layer.sticky.start * height;
        const end = layer.sticky.end * height;
        const isSticky = scrollTop >= start && scrollTop <= end;
        if (isSticky === layer.isSticky)
          return;
        layer.isSticky = isSticky;
        const ref2 = layerRef.current;
        ref2.style.position = isSticky ? "sticky" : "absolute";
        ctrl.set({
          translate: isSticky ? 0 : scrollTop < start ? start : end
        });
      };
      useOnce(() => {
        if (parent) {
          parent.layers.add(layer);
          parent.update();
          return () => {
            parent.layers.delete(layer);
            parent.update();
          };
        }
      });
      const translate3d = ctrl.springs.translate.to(
        layer.horizontal ? (x) => `translate3d(${x}px,0,0)` : (y) => `translate3d(0,${y}px,0)`
      );
      return React.createElement(
        animated.div,
        {
          ...rest,
          ref: layerRef,
          style: {
            position: "absolute",
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            backgroundSize: "auto",
            backgroundRepeat: "no-repeat",
            willChange: "transform",
            [layer.horizontal ? "height" : "width"]: "100%",
            [layer.horizontal ? "width" : "height"]: ctrl.springs.space,
            WebkitTransform: translate3d,
            msTransform: translate3d,
            transform: translate3d,
            ...rest.style
          }
        }
      );
    }
  )
);
var Parallax = React.memo(
  React.forwardRef((props, ref) => {
    const [ready, setReady] = (0, import_react.useState)(false);
    const {
      pages,
      innerStyle: _innerStyle,
      config: config2 = config.slow,
      enabled = true,
      horizontal = false,
      children,
      ...rest
    } = props;
    const containerRef = (0, import_react.useRef)();
    const contentRef = (0, import_react.useRef)();
    const state = useMemoOne(
      () => ({
        config: config2,
        horizontal,
        busy: false,
        space: 0,
        current: 0,
        offset: 0,
        controller: new Controller({ scroll: 0 }),
        layers: /* @__PURE__ */ new Set(),
        container: containerRef,
        content: contentRef,
        update: () => update(),
        scrollTo: (offset) => scrollTo(offset),
        stop: () => state.controller.stop()
      }),
      []
    );
    (0, import_react.useEffect)(() => {
      state.config = config2;
    }, [config2]);
    React.useImperativeHandle(ref, () => state);
    const update = () => {
      const container = containerRef.current;
      if (!container)
        return;
      const spaceProp = horizontal ? "clientWidth" : "clientHeight";
      state.space = container[spaceProp];
      const scrollType = getScrollType(horizontal);
      if (enabled) {
        state.current = container[scrollType];
      } else {
        container[scrollType] = state.current = state.offset * state.space;
      }
      const content = contentRef.current;
      if (content) {
        const sizeProp = horizontal ? "width" : "height";
        content.style[sizeProp] = `${state.space * pages}px`;
      }
      state.layers.forEach((layer) => {
        layer.setHeight(state.space, true);
        layer.setPosition(state.space, state.current, true);
      });
    };
    const scrollTo = (offset) => {
      const container = containerRef.current;
      const scrollType = getScrollType(horizontal);
      state.offset = offset;
      state.controller.set({ scroll: state.current });
      state.controller.stop().start({
        scroll: offset * state.space,
        config: config2,
        onChange({ value: { scroll } }) {
          container[scrollType] = scroll;
        }
      });
    };
    const onScroll = (event) => {
      if (!state.busy) {
        state.busy = true;
        state.current = event.target[getScrollType(horizontal)];
        raf.onStart(() => {
          state.layers.forEach(
            (layer) => layer.setPosition(state.space, state.current)
          );
          state.busy = false;
        });
      }
    };
    (0, import_react.useEffect)(() => state.update());
    useOnce(() => {
      setReady(true);
      const onResize = () => {
        const update2 = () => state.update();
        raf.onFrame(update2);
        setTimeout(update2, 150);
      };
      window.addEventListener("resize", onResize, false);
      return () => window.removeEventListener("resize", onResize, false);
    });
    const overflow = enabled ? {
      overflowY: horizontal ? "hidden" : "scroll",
      overflowX: horizontal ? "scroll" : "hidden"
    } : {
      overflowY: "hidden",
      overflowX: "hidden"
    };
    return React.createElement(
      animated.div,
      {
        ...rest,
        ref: containerRef,
        onScroll,
        onWheel: enabled ? state.stop : void 0,
        onTouchStart: enabled ? state.stop : void 0,
        style: {
          position: "absolute",
          width: "100%",
          height: "100%",
          ...overflow,
          WebkitOverflowScrolling: "touch",
          WebkitTransform: START_TRANSLATE,
          msTransform: START_TRANSLATE,
          transform: START_TRANSLATE_3D,
          ...rest.style
        }
      },
      ready && React.createElement(React.Fragment, null, React.createElement(
        animated.div,
        {
          ref: contentRef,
          style: {
            overflow: "hidden",
            position: "absolute",
            [horizontal ? "height" : "width"]: "100%",
            [horizontal ? "width" : "height"]: state.space * pages,
            WebkitTransform: START_TRANSLATE,
            msTransform: START_TRANSLATE,
            transform: START_TRANSLATE_3D,
            ...props.innerStyle
          }
        },
        React.createElement(ParentContext.Provider, { value: state }, mapChildrenRecursive(
          children,
          (child) => !child.props.sticky && child
        ))
      ), React.createElement(ParentContext.Provider, { value: state }, mapChildrenRecursive(
        children,
        (child) => child.props.sticky && child
      )))
    );
  })
);
export {
  Parallax,
  ParallaxLayer
};
//# sourceMappingURL=@react-spring_parallax.js.map
